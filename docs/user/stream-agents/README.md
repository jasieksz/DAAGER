---
title: Stream Agents reference
---

# Stream Agents reference

Stream Agents is a module providing a general multi-agent system that is a base for various more concrete implementations of agent-based computations.
Currently, besides the base code, it offers a base implementation for Evolutionary Multi-Agent Systems.

Stream Agents extensively use immutable collections and utilities from [Javaslang][javaslang].
You need to keep that in mind when performing actions on collections returned from methods.
Moreover, all objects are immutable if not mentioned otherwise.

## Basic concepts

- **Agent** (`Agent` interface) is just a serializable container for data and operations.
- **Workplace** (`Workplace` class) is a threaded context for a population of agents.
- **Pipeline** (`Pipeline` class) is a stream-based definition of operations to execute on a population of agents.
- **Environment** (`Environment` class) is a view of the system provided to agents.
 
### Workplace

Workplaces are main executors for the Stream Agents computation.
Each workplace executes in a separate thread and works asynchronously in relation to others.

Workplace operation is defined by the following operators:

- before step action,
- step,
- after step action.

Moreover, each workplace has an id nad an initial population of agents.

**Before step action** is defined as a function of three arguments:
 
- step number,
- current population,
- incoming population (coming from migrations).

And returns a population for the current step (usually just merge between current and incoming agents).

**Step** is a main computation operation that should contain code that changes population.
It receives a current population (returned from the **before step action**) and the reference to the environment.

**After step action** is usually used to collect statistics. It receives the following arguments:

- id of the workplace,
- step number,
- current population (generated by the **step**).

And it returns the map of statistics.

#### Environment

**Environment** is the only view of the global computation accessible to agents and operators.
It is a way for them to gain the limited knowledge of the world and perform interactions with other populations.

Environment makes it possible to:

- gain the knowledge about workplaces (*id* and *count* of workplaces, list of neighbour workplaces),
- gain the knowledge about other populations statistics (`workplaceStatistics)

### Pipeline

Pipeline defines a stream-like, functional operation on the population of agents.
The base class is `pl.edu.agh.age.compute.stream.Pipeline`,
however it is expected that more concrete computation types will provide more adequate implementations.

Basically, the concept behind pipeline is to provide a functional and easy way to define transformations over the population.
For example:

```java
Pipeline.on(population)
        .selectPairs(selector)
        .reproduce(reproduction)
        .selectPairs(selector)
        .fight(fight);
```

Pipelines are eagerly evaluated. It is currently required in order to support splitting populations.

### Stop condition

**Stop condition** (`StopCondition` interface) defines conditions under which the computation is gracefully stopped.
Currently, only time-based stop condition implementation is provided.
 
Stop condition is global for the whole computation. If it is fulfilled, all of the workplaces initiate shutdown.

## Evolutionary Multi-Agent Systems

> **Note:** To get the overview of the EMAS model, you should read one of [our publications][bib].
> This documentation contains only a technical description of the implementation.

EMAS API and implementation is located in the `pl.edu.agh.age.compute.stream.emas` package.

### Agent and solutions

The agent class is `EmasAgent`. Each agent has the following properties:

- **id**,
- **energy**,
- **solution**.

The equality of agents is based on their **id**.

**Energy** is a simple double value.

**Solution** is defined in the interface `pl.edu.agh.age.compute.stream.emas.solution.Solution`.
It is a wrapper over a particular solution value (for example, for a `double` number) with a fitness value attached.
However, it is not required for the fitness to be present (in that case `NaN` will be returned).

A concrete implementation of the solution will be dependent on the computation, but some of the most commonly used types are already provided:
 
- `DoubleSolution` – a single double value.
- `DoubleVectorSolution` – a vector of double values.
- `SimpleSolution` – a wrapper over any object.

### Pipeline

The pipeline for the EMAS provides some dedicated operations:

- `Tuple2<PairPipeline, Pipeline> selectPairs(BiFunction<EmasAgent, List<EmasAgent>, Tuple2<EmasAgent, EmasAgent>> selector)`
  Selects pairs of agents using the given selector.
  
- `PairPipeline selectPairsWithRepetitions(final BiFunction<EmasAgent, List<EmasAgent>, Tuple2<EmasAgent, EmasAgent>> selector)`
  Selects pairs of agents using the given selector but allow repetitions.
   
- `Tuple2<Pipeline, Pipeline> migrateWhen(Predicate<EmasAgent> migrationPredicate)`
  Chooses agents for migration using the given predicate.
  
- `Tuple2<Pipeline, Pipeline> dieWhen(Predicate<EmasAgent> deathPredicate)`
  Chooses agents that should die using the given predicate.
  
`migrateWhen` and `dieWhen` are identical in behavior but they are differentiated for better semantics.
Both return two separate pipelines: one for selected and one for unselected agents.

`selectPairs` and `selectPairsWithRepetitions` make it possible to pair agents. 
The first version guarantees that the `selector` will not receive already selected agents.
In that case it is possible that not all agents could be paired and they are returned in the second element of the tuple.

### Agents interaction

Agents can interact in two ways: by reproducing and by fighting.

**Reproduction** is provided by the `pl.edu.agh.age.compute.stream.emas.reproduction` package. Currently only sexual reproduction is implemented.
It is also based on a *pipeline* concept but it is usually better to prepare the pipeline beforehand using provided builder: `SexualReproductionBuilder`
The sexual reproduction always work on pairs ofa agents and is built using the following operations:

- recombination,
- mutation,
- evaluation,
- improvement,
- energy transfer.

When using the builder, the recombination, evaluation and energy transfer operators are required to be provided
and all operations are executed in the order specified in the list (that is, in the most common order).
 
The meaning of these operations is equivalent to genetic algorithms.
All of them, beside *energy transfer*, operate on solutions.

The sexual reproduction always generates a sequence of agents: two parents and one child.
Please, note, that the parents returned from the pipeline usually have energy levels changed by the *energy transfer* operator.
   
**Fighting** is located in the `pl.edu.agh.age.compute.stream.emas.fight` package.
It is much simpler than reproduction, as it only performs two operations:

- comparison of two agents (using **Comparator**),
- energy transfer.

The fight generates a sequence of agents – the same agents that were passed to it, but with changed energy levels.

[bib]: https://www.age.agh.edu.pl/bibliography/emas/
[javaslang]: http://www.javaslang.io/
